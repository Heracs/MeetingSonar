//
//  AISettingsView.swift
//  MeetingSonar
//
//  Created by MeetingSonar Team.
//  Copyright © 2024 MeetingSonar. All rights reserved.
//

import SwiftUI

/// Settings view for AI Model Management.
/// Implements F-5.12 AI Model Status UI.
@available(macOS 13.0, *)
@available(macOS 13.0, *)
struct AISettingsView: View {
    @ObservedObject private var settings = SettingsManager.shared
    
    var body: some View {
        TabView {
            // Local Models Tab
            Form {
                Section(header: Text("System Compatibility")) {
                    let isAppleSilicon = SystemChecker.isAppleSilicon
                    let hasMem = SystemChecker.hasMinimumMemoryForAI
                    
                    HStack {
                        Image(systemName: isAppleSilicon ? "cpu" : "exclamationmark.triangle")
                            .foregroundColor(isAppleSilicon ? .green : .red)
                        Text(SystemChecker.detectChipType().displayName)
                        Spacer()
                        if !isAppleSilicon {
                            Text("Unsupported")
                                .foregroundColor(.red)
                                .font(.caption)
                        }
                    }
                    
                    HStack {
                        Image(systemName: hasMem ? "memorychip" : "exclamationmark.triangle")
                            .foregroundColor(hasMem ? .green : .orange)
                        Text("Memory Check")
                        Spacer()
                        Text(hasMem ? "OK" : "Low (< 8GB)")
                            .foregroundColor(hasMem ? .secondary : .orange)
                            .font(.caption)
                    }
                }
                
                // ASR Models Group
                Section(header: Text("Speech Recognition (ASR)")) {
                    ForEach(ModelType.asrModels) { type in
                        ModelSelectionRow(
                            type: type,
                            isSelected: settings.selectedASRModel == type.rawValue,
                            onSelect: {
                                settings.selectedASRModel = type.rawValue
                            }
                        )
                    }
                }
                
                // LLM Models Group
                Section(header: Text("Language Models (LLM)")) {
                    ForEach(ModelType.llmModels) { type in
                        ModelSelectionRow(
                            type: type,
                            isSelected: settings.selectedLLMModel == type.rawValue,
                            onSelect: {
                                settings.selectedLLMModel = type.rawValue
                            }
                        )
                    }
                }
                
                // VAD (System)
                Section(header: Text("System Models (VAD)")) {
                    ForEach(ModelType.vadModels) { type in
                       ModelRowView(type: type)
                    }
                }
                
                Section(footer: Text("Total space required: ~2-5 GB depending on selection. Models are stored in ~/Documents/MeetingSonar_Data/Models/")) {
                    EmptyView()
                }
            }
            .padding()
            .tabItem { Label("本地模型", systemImage: "laptopcomputer") }
            
            // F-9.3: Online Models Tab
            OnlineModelsListView()
                .tabItem { Label("在线模型", systemImage: "cloud") }
        }
    }
}

@available(macOS 13.0, *)
struct ModelSelectionRow: View {
    let type: ModelType
    let isSelected: Bool
    let onSelect: () -> Void
    
    @State private var status: ModelStatus = .notDownloaded
    @State private var isChecking = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 5) {
            HStack {
                // Radio Button for Selection
                Button {
                    onSelect()
                    // Auto-trigger download if selected and missing?
                    if !status.isReady {
                       startDownload()
                    }
                } label: {
                    Image(systemName: isSelected ? "largecircle.fill.circle" : "circle")
                        .foregroundColor(isSelected ? .blue : .secondary)
                }
                .buttonStyle(.plain)
                
                // Reuse existing ModelRowView logic for content, but wrapped
                ModelRowView(type: type)
            }
            .padding(.vertical, 4)
            .background(isSelected ? Color.blue.opacity(0.05) : Color.clear)
            .cornerRadius(6)
        }
        .onAppear {
            checkStatus()
        }
        .onChange(of: isSelected) { newValue in
            if newValue && !status.isReady {
                // If user selects this model, checking persistence or auto-download hint
            }
        }
    }
    
    private func checkStatus() {
        Task {
            status = await ModelManager.shared.checkStatus(for: type)
        }
    }
    
    private func startDownload() {
        Task {
            try? await ModelManager.shared.download(type: type) { _ in }
        }
    }
}

@available(macOS 13.0, *)
struct ModelRowView: View {
    let type: ModelType
    
    @State private var status: ModelStatus = .notDownloaded
    @State private var isChecking = false
    @State private var verificationResult: Bool? = nil
    @State private var showDeleteAlert = false
    
    var body: some View {
        HStack {
            Image(systemName: iconForType(type))
                .font(.title2)
                .frame(width: 30)
                .foregroundColor(.secondary)
            
            VStack(alignment: .leading) {
                Text(type.displayName)
                    .font(.headline)
                    .foregroundColor(status == .downloaded ? .primary : .secondary)
                
                HStack {
                    Text(ModelManager.formatBytes(type.approximateSizeBytes))
                    if let valid = verificationResult {
                        Text(valid ? "Verified" : "Corrupt")
                            .foregroundColor(valid ? .green : .red)
                            .fontWeight(.medium)
                    }
                }
                .font(.caption)
                .foregroundColor(.secondary)
            }
            
            Spacer()
            
            switch status {
            case .notDownloaded:
                Button("Download") {
                    startDownload()
                }
                .accessibilityIdentifier("Button_Download_\(type.rawValue)")
                .buttonStyle(.borderedProminent)
                .controlSize(.small)
                
            case .downloading(let progress):
                VStack(alignment: .trailing) {
                    ProgressView(value: progress)
                        .progressViewStyle(.linear)
                        .frame(width: 80)
                    Text("\(Int(progress * 100))%")
                        .font(.caption)
                }
                
            case .downloaded:
                HStack(spacing: 8) {
                    Button { verifyModel() } label: {
                        Image(systemName: "checkmark.shield")
                    }
                    .buttonStyle(.plain)
                    .help("Verify")
                    .disabled(isChecking)
                    
                    Button { ModelManager.shared.revealInFinder(type: type) } label: {
                        Image(systemName: "folder")
                    }
                    .buttonStyle(.plain)
                    .help("Reveal")
                    
                    Button { showDeleteAlert = true } label: {
                        Image(systemName: "trash").foregroundColor(.red)
                    }
                    .buttonStyle(.plain)
                    .help("Delete")
                    .alert("Delete Model?", isPresented: $showDeleteAlert) {
                        Button("Delete", role: .destructive) { deleteModel() }
                        Button("Cancel", role: .cancel) {}
                    } message: { Text("Delete \(type.displayName)?") }
                }
                
            case .failed(let msg):
                HStack {
                    Image(systemName: "exclamationmark.triangle")
                        .foregroundColor(.red)
                        .help(msg)
                    Button("Retry") { startDownload() }
                        .controlSize(.small)
                }
            }
        }
        .onAppear { checkStatus() }
    }
    
    func iconForType(_ type: ModelType) -> String {
        if type.isASR { return "ear" }
        if type.isLLM { return "brain.head.profile" }
        return "waveform.path.ecg"
    }
    
    private func checkStatus() {
        Task {
            isChecking = true
            let current = await ModelManager.shared.checkStatus(for: type)
            await MainActor.run {
                self.status = current
                isChecking = false
                if current != .downloaded { verificationResult = nil }
            }
        }
    }
    
    private func startDownload() {
        Task {
            await MainActor.run { status = .downloading(progress: 0); verificationResult = nil }
            do {
                try await ModelManager.shared.download(type: type) { p in
                    Task { @MainActor in self.status = .downloading(progress: p) }
                }
                checkStatus()
            } catch {
                await MainActor.run { self.status = .failed(message: error.localizedDescription) }
            }
        }
    }
    
    private func verifyModel() {
        Task {
            isChecking = true
            let isValid = try? await ModelManager.shared.verifyModel(type: type)
            await MainActor.run { self.verificationResult = isValid; isChecking = false }
        }
    }
    
    private func deleteModel() {
        Task {
            try? await ModelManager.shared.delete(type: type)
            checkStatus()
        }
    }
}

//
//  OnlineModelType.swift
//  MeetingSonar
//
//  F-9.3: Online model type enumeration (ASR/LLM)
//

import Foundation

/// Type of online AI model
enum OnlineModelType: String, Codable {
    case asr = "asr"
    case llm = "llm"
    
    var displayName: String {
        switch self {
        case .asr: return "语音识别 (ASR)"
        case .llm: return "语言模型 (LLM)"
        }
    }
}
//
//  OnlineServiceProvider.swift
//  MeetingSonar
//
//  F-9.3: Online service provider enumeration with default configurations
//

import Foundation

/// Supported online AI service providers
enum OnlineServiceProvider: String, Codable, CaseIterable {
    case zhipu = "zhipu"
    case deepseek = "deepseek"
    case qwen = "qwen"
    
    var displayName: String {
        switch self {
        case .zhipu: return "智谱AI"
        case .deepseek: return "DeepSeek"
        case .qwen: return "阿里千问"
        }
    }
    
    var defaultBaseURL: String {
        switch self {
        case .zhipu: return "https://open.bigmodel.cn"
        case .deepseek: return "https://api.deepseek.com"
        case .qwen: return "https://dashscope.aliyuncs.com"
        }
    }
    
    /// Get default model name for specified type
    func defaultModel(for type: OnlineModelType) -> String {
        switch (self, type) {
        case (.zhipu, .asr): return "whisper-1"
        case (.zhipu, .llm): return "glm-4.7"
        case (.deepseek, .asr): return "whisper-1"
        case (.deepseek, .llm): return "deepseek-chat"
        case (.qwen, .asr): return "paraformer-v2"
        case (.qwen, .llm): return "qwen-turbo"
        }
    }
    
    /// Get verification API path for specified type
    func verificationPath(for type: OnlineModelType) -> String {
        switch (self, type) {
        case (.zhipu, .asr): return "/api/paas/v4/audio/transcriptions"
        case (.zhipu, .llm): return "/api/paas/v4/chat/completions"
        case (.deepseek, .asr): return "/v1/audio/transcriptions"
        case (.deepseek, .llm): return "/v1/chat/completions"
        case (.qwen, .asr): return "/api/v1/services/asr/transcription"
        case (.qwen, .llm): return "/api/v1/services/aigc/text-generation/generation"
        }
    }
}
//
//  OnlineModelConfig.swift
//  MeetingSonar
//
//  F-9.3: Online model configuration data structure
//

import Foundation

/// Configuration for an online AI model
struct OnlineModelConfig: Codable, Identifiable, Hashable {
    
    // MARK: - Core Properties
    
    /// Unique identifier
    let id: UUID
    
    /// Service provider
    var provider: OnlineServiceProvider
    
    /// Model name (e.g., "whisper-1", "glm-4.7")
    var modelName: String
    
    /// Base URL for API endpoint
    var baseURL: String
    
    /// Whether the configuration has been verified
    var isVerified: Bool
    
    // MARK: - Model Parameters (Optional)
    
    /// Temperature parameter (0.0-2.0)
    var temperature: Double?
    
    /// Max tokens for response
    var maxTokens: Int?
    
    /// Top P parameter (LLM only, 0.0-1.0)
    var topP: Double?
    
    // MARK: - Initializer
    
    init(
        id: UUID = UUID(),
        provider: OnlineServiceProvider,
        modelName: String,
        baseURL: String,
        isVerified: Bool = false,
        temperature: Double? = nil,
        maxTokens: Int? = nil,
        topP: Double? = nil
    ) {
        self.id = id
        self.provider = provider
        self.modelName = modelName
        self.baseURL = baseURL
        self.isVerified = isVerified
        self.temperature = temperature
        self.maxTokens = maxTokens
        self.topP = topP
    }
    
    // MARK: - Factory Methods
    
    /// Create a new configuration with default values for specified provider and type
    static func defaultConfig(provider: OnlineServiceProvider, type: OnlineModelType) -> OnlineModelConfig {
        return OnlineModelConfig(
            provider: provider,
            modelName: provider.defaultModel(for: type),
            baseURL: provider.defaultBaseURL,
            temperature: type == .llm ? 0.7 : 0.0,
            maxTokens: type == .llm ? 4096 : 1000,
            topP: type == .llm  ? 0.95 : nil
        )
    }
}
//
//  OnlineModelManager.swift
//  MeetingSonar
//
//  F-9.3: Manage online model configurations (CRUD operations)
//

import Foundation

/// Manager for online model configurations
@MainActor
final class OnlineModelManager: ObservableObject {
    
    static let shared = OnlineModelManager()
    
    // MARK: - Published Properties
    
    @Published private(set) var asrModels: [OnlineModelConfig] = []
    @Published private(set) var llmModels: [OnlineModelConfig] = []
    
    // MARK: - Properties
    
    private let defaults = UserDefaults.standard
    private let keychainService = KeychainService.shared
    
    private let asrModelsKey = "onlineASRModels"
    private let llmModelsKey = "onlineLLMModels"
    
    // MARK: - Initialization
    
    private init() {
        loadAllConfigs()
    }
    
    // MARK: - Public API
    
    /// Add a new model configuration
    /// - Parameters:
    ///   - config: Model configuration to add
    ///   - apiKey: API Key (will be saved to Keychain)
    ///   - type: Model type (ASR/LLM)
    /// - Throws: KeychainError if saving API Key fails
    func add(config: OnlineModelConfig, apiKey: String, type: OnlineModelType) throws {
        // Save API Key to Keychain
        try keychainService.save(key: apiKey, for: config.id.uuidString, modelType: type)
        
        // Add config to array
        switch type {
        case .asr:
            asrModels.append(config)
            saveConfigs(asrModels, key: asrModelsKey)
        case .llm:
            llmModels.append(config)
            saveConfigs(llmModels, key: llmModelsKey)
        }
        
        LoggerService.shared.log(
            category: .general,
            message: "[OnlineModelManager] Added \(type.rawValue) model: \(config.provider.displayName) - \(config.modelName)"
        )
    }
    
    /// Update an existing model configuration
    /// - Parameters:
    ///   - config: Updated configuration
    ///   - apiKey: New API Key (optional, leave nil to keep existing)
    ///   - type: Model type (ASR/LLM)
    /// - Throws: KeychainError if updating API Key fails
    func update(config: OnlineModelConfig, apiKey: String?, type: OnlineModelType) throws {
        // Update API Key if provided
        if let newKey = apiKey {
            try keychainService.save(key: newKey, for: config.id.uuidString, modelType: type)
        }
        
        // Update config in array
        switch type {
        case .asr:
            if let index = asrModels.firstIndex(where: { $0.id == config.id }) {
                asrModels[index] = config
                saveConfigs(asrModels, key: asrModelsKey)
            }
        case .llm:
            if let index = llmModels.firstIndex(where: { $0.id == config.id }) {
                llmModels[index] = config
                saveConfigs(llmModels, key: llmModelsKey)
            }
        }
        
        LoggerService.shared.log(
            category: .general,
            message: "[OnlineModelManager] Updated \(type.rawValue) model: \(config.id)"
        )
    }
    
    /// Delete a model configuration
    /// - Parameters:
    ///   - config: Configuration to delete
    ///   - type: Model type (ASR/LLM)
    /// - Throws: KeychainError if deleting API Key fails
    func delete(config: OnlineModelConfig, type: OnlineModelType) throws {
        // Delete API Key from Keychain
        try keychainService.delete(for: config.id.uuidString, modelType: type)
        
        // Remove config from array
        switch type {
        case .asr:
            asrModels.removeAll { $0.id == config.id }
            saveConfigs(asrModels, key: asrModelsKey)
        case .llm:
            llmModels.removeAll { $0.id == config.id }
            saveConfigs(llmModels, key: llmModelsKey)
        }
        
        LoggerService.shared.log(
            category: .general,
            message: "[OnlineModelManager] Deleted \(type.rawValue) model: \(config.id)"
        )
    }
    
    /// Get API Key for a model configuration
    /// - Parameters:
    ///   - config: Model configuration
    ///   - type: Model type
    /// - Returns: API Key string, or nil if not found
    func getAPIKey(for config: OnlineModelConfig, type: OnlineModelType) -> String? {
        return keychainService.load(for: config.id.uuidString, modelType: type)
    }
    
    // MARK: - Private Helpers
    
    private func loadAllConfigs() {
        // Load ASR models
        if let data = defaults.data(forKey: asrModelsKey),
           let configs = try? JSONDecoder().decode([OnlineModelConfig].self, from: data) {
            asrModels = configs
        }
        
        // Load LLM models
        if let data = defaults.data(forKey: llmModelsKey),
           let configs = try? JSONDecoder().decode([OnlineModelConfig].self, from: data) {
            llmModels = configs
        }
    }
    
    private func saveConfigs(_ configs: [OnlineModelConfig], key: String) {
        if let data = try? JSONEncoder().encode(configs) {
            defaults.set(data, forKey: key)
        }
    }
}
//
//  APIKeyVerifier.swift
//  MeetingSonar
//
//  F-9.3: API Key verification logic for online service providers
//

import Foundation

/// Verification result
enum VerificationResult {
    case success
    case failure(String)
}

/// Service for verifying API Keys
@MainActor
final class APIKeyVerifier {
    
    static let shared = APIKeyVerifier()
    
    private init() {}
    
    // MARK: - Public API
    
    /// Verify API Key by making a test request to the service provider
    /// - Parameters:
    ///   - config: Model configuration to verify
    ///   - apiKey: API Key to verify
    ///   - type: Model type (ASR/LLM)
    /// - Returns: Verification result
    func verify(config: OnlineModelConfig, apiKey: String, type: OnlineModelType) async -> VerificationResult {
        
        LoggerService.shared.log(
            category: .general,
            message: "[APIKeyVerifier] Verifying \(config.provider.displayName) \(type.rawValue) model"
        )
        
        // Construct URL
        let baseURL = config.baseURL
        let path = config.provider.verificationPath(for: type)
        
        guard let url = URL(string: baseURL + path) else {
            return .failure("无效的 Base URL")
        }
        
        // Create request
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Add authorization header (provider-specific)
        switch config.provider {
        case .zhipu:
            request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        case .deepseek:
            request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        case .qwen:
            request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        }
        
        // Create minimal test payload
        let testPayload = createTestPayload(for: config, type: type)
        request.httpBody = testPayload
        
        // Make request
        do {
            let (data, response) = try await URLSession.shared.data(for: request)
            
            guard let httpResponse = response as? HTTPURLResponse else {
                return .failure("无效的响应")
            }
            
            // Check status code
            if httpResponse.statusCode == 200 || httpResponse.statusCode == 201 {
                LoggerService.shared.log(
                    category: .general,
                    message: "[APIKeyVerifier] Verification successful"
                )
                return .success
            } else {
                // Parse error message
                let errorMessage = parseErrorMessage(from: data, provider: config.provider)
                return .failure("验证失败 (\(httpResponse.statusCode)): \(errorMessage)")
            }
            
        } catch {
            LoggerService.shared.log(
                category: .error,
                message: "[APIKeyVerifier] Verification error: \(error.localizedDescription)"
            )
            return .failure("网络错误: \(error.localizedDescription)")
        }
    }
    
    // MARK: - Private Helpers
    
    private func createTestPayload(for config: OnlineModelConfig, type: OnlineModelType) -> Data? {
        var payload: [String: Any] = [:]
        
        switch (config.provider, type) {
        case (.zhipu, .llm), (.deepseek, .llm):
            // Minimal LLM completion request
            payload = [
                "model": config.modelName,
                "messages": [
                    ["role": "user", "content": "Hi"]
                ],
                "max_tokens": 1
            ]
            
        case (.qwen, .llm):
            // Qwen LLM format
            payload = [
                "model": config.modelName,
                "input": [
                    "messages": [
                        ["role": "user", "content": "Hi"]
                    ]
                ],
                "parameters": [
                    "max_tokens": 1
                ]
            ]
            
        case (_, .asr):
            // For ASR, we'll use a minimal payload
            // Note: Real ASR verification would require an audio file
            // For now, we'll just test authentication
            payload = [
                "model": config.modelName
            ]
        }
        
        return try? JSONSerialization.data(withJSONObject: payload)
    }
    
    private func parseErrorMessage(from data: Data, provider: OnlineServiceProvider) -> String {
        guard let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            return "未知错误"
        }
        
        // Try common error message fields
        if let error = json["error"] as? [String: Any],
           let message = error["message"] as? String {
            return message
        }
        
        if let message = json["message"] as? String {
            return message
        }
        
        if let errorMsg = json["error_msg"] as? String {
            return errorMsg
        }
        
        return "未知错误"
    }
}
//
//  OnlineModelType.swift
//  MeetingSonar
//
//  F-9.3: Online model type enumeration (ASR/LLM)
//

import Foundation

/// Type of online AI model
enum OnlineModelType: String, Codable {
    case asr = "asr"
    case llm = "llm"
    
    var displayName: String {
        switch self {
        case .asr: return "语音识别 (ASR)"
        case .llm: return "语言模型 (LLM)"
        }
    }
}
//
//  OnlineServiceProvider.swift
//  MeetingSonar
//
//  F-9.3: Online service provider enumeration with default configurations
//

import Foundation

/// Supported online AI service providers
enum OnlineServiceProvider: String, Codable, CaseIterable {
    case zhipu = "zhipu"
    case deepseek = "deepseek"
    case qwen = "qwen"
    
    var displayName: String {
        switch self {
        case .zhipu: return "智谱AI"
        case .deepseek: return "DeepSeek"
        case .qwen: return "阿里千问"
        }
    }
    
    var defaultBaseURL: String {
        switch self {
        case .zhipu: return "https://open.bigmodel.cn"
        case .deepseek: return "https://api.deepseek.com"
        case .qwen: return "https://dashscope.aliyuncs.com"
        }
    }
    
    /// Get default model name for specified type
    func defaultModel(for type: OnlineModelType) -> String {
        switch (self, type) {
        case (.zhipu, .asr): return "whisper-1"
        case (.zhipu, .llm): return "glm-4.7"
        case (.deepseek, .asr): return "whisper-1"
        case (.deepseek, .llm): return "deepseek-chat"
        case (.qwen, .asr): return "paraformer-v2"
        case (.qwen, .llm): return "qwen-turbo"
        }
    }
    
    /// Get verification API path for specified type
    func verificationPath(for type: OnlineModelType) -> String {
        switch (self, type) {
        case (.zhipu, .asr): return "/api/paas/v4/audio/transcriptions"
        case (.zhipu, .llm): return "/api/paas/v4/chat/completions"
        case (.deepseek, .asr): return "/v1/audio/transcriptions"
        case (.deepseek, .llm): return "/v1/chat/completions"
        case (.qwen, .asr): return "/api/v1/services/asr/transcription"
        case (.qwen, .llm): return "/api/v1/services/aigc/text-generation/generation"
        }
    }
}
//
//  OnlineModelConfig.swift
//  MeetingSonar
//
//  F-9.3: Online model configuration data structure
//

import Foundation

/// Configuration for an online AI model
struct OnlineModelConfig: Codable, Identifiable, Hashable {
    
    // MARK: - Core Properties
    
    /// Unique identifier
    let id: UUID
    
    /// Service provider
    var provider: OnlineServiceProvider
    
    /// Model name (e.g., "whisper-1", "glm-4.7")
    var modelName: String
    
    /// Base URL for API endpoint
    var baseURL: String
    
    /// Whether the configuration has been verified
    var isVerified: Bool
    
    // MARK: - Model Parameters (Optional)
    
    /// Temperature parameter (0.0-2.0)
    var temperature: Double?
    
    /// Max tokens for response
    var maxTokens: Int?
    
    /// Top P parameter (LLM only, 0.0-1.0)
    var topP: Double?
    
    // MARK: - Initializer
    
    init(
        id: UUID = UUID(),
        provider: OnlineServiceProvider,
        modelName: String,
        baseURL: String,
        isVerified: Bool = false,
        temperature: Double? = nil,
        maxTokens: Int? = nil,
        topP: Double? = nil
    ) {
        self.id = id
        self.provider = provider
        self.modelName = modelName
        self.baseURL = baseURL
        self.isVerified = isVerified
        self.temperature = temperature
        self.maxTokens = maxTokens
        self.topP = topP
    }
    
    // MARK: - Factory Methods
    
    /// Create a new configuration with default values for specified provider and type
    static func defaultConfig(provider: OnlineServiceProvider, type: OnlineModelType) -> OnlineModelConfig {
        return OnlineModelConfig(
            provider: provider,
            modelName: provider.defaultModel(for: type),
            baseURL: provider.defaultBaseURL,
            temperature: type == .llm ? 0.7 : 0.0,
            maxTokens: type == .llm ? 4096 : 1000,
            topP: type == .llm  ? 0.95 : nil
        )
    }
}
//
//  OnlineModelManager.swift
//  MeetingSonar
//
//  F-9.3: Manage online model configurations (CRUD operations)
//

import Foundation

/// Manager for online model configurations
@MainActor
final class OnlineModelManager: ObservableObject {
    
    static let shared = OnlineModelManager()
    
    // MARK: - Published Properties
    
    @Published private(set) var asrModels: [OnlineModelConfig] = []
    @Published private(set) var llmModels: [OnlineModelConfig] = []
    
    // MARK: - Properties
    
    private let defaults = UserDefaults.standard
    private let keychainService = KeychainService.shared
    
    private let asrModelsKey = "onlineASRModels"
    private let llmModelsKey = "onlineLLMModels"
    
    // MARK: - Initialization
    
    private init() {
        loadAllConfigs()
    }
    
    // MARK: - Public API
    
    /// Add a new model configuration
    /// - Parameters:
    ///   - config: Model configuration to add
    ///   - apiKey: API Key (will be saved to Keychain)
    ///   - type: Model type (ASR/LLM)
    /// - Throws: KeychainError if saving API Key fails
    func add(config: OnlineModelConfig, apiKey: String, type: OnlineModelType) throws {
        // Save API Key to Keychain
        try keychainService.save(key: apiKey, for: config.id.uuidString, modelType: type)
        
        // Add config to array
        switch type {
        case .asr:
            asrModels.append(config)
            saveConfigs(asrModels, key: asrModelsKey)
        case .llm:
            llmModels.append(config)
            saveConfigs(llmModels, key: llmModelsKey)
        }
        
        LoggerService.shared.log(
            category: .general,
            message: "[OnlineModelManager] Added \(type.rawValue) model: \(config.provider.displayName) - \(config.modelName)"
        )
    }
    
    /// Update an existing model configuration
    /// - Parameters:
    ///   - config: Updated configuration
    ///   - apiKey: New API Key (optional, leave nil to keep existing)
    ///   - type: Model type (ASR/LLM)
    /// - Throws: KeychainError if updating API Key fails
    func update(config: OnlineModelConfig, apiKey: String?, type: OnlineModelType) throws {
        // Update API Key if provided
        if let newKey = apiKey {
            try keychainService.save(key: newKey, for: config.id.uuidString, modelType: type)
        }
        
        // Update config in array
        switch type {
        case .asr:
            if let index = asrModels.firstIndex(where: { $0.id == config.id }) {
                asrModels[index] = config
                saveConfigs(asrModels, key: asrModelsKey)
            }
        case .llm:
            if let index = llmModels.firstIndex(where: { $0.id == config.id }) {
                llmModels[index] = config
                saveConfigs(llmModels, key: llmModelsKey)
            }
        }
        
        LoggerService.shared.log(
            category: .general,
            message: "[OnlineModelManager] Updated \(type.rawValue) model: \(config.id)"
        )
    }
    
    /// Delete a model configuration
    /// - Parameters:
    ///   - config: Configuration to delete
    ///   - type: Model type (ASR/LLM)
    /// - Throws: KeychainError if deleting API Key fails
    func delete(config: OnlineModelConfig, type: OnlineModelType) throws {
        // Delete API Key from Keychain
        try keychainService.delete(for: config.id.uuidString, modelType: type)
        
        // Remove config from array
        switch type {
        case .asr:
            asrModels.removeAll { $0.id == config.id }
            saveConfigs(asrModels, key: asrModelsKey)
        case .llm:
            llmModels.removeAll { $0.id == config.id }
            saveConfigs(llmModels, key: llmModelsKey)
        }
        
        LoggerService.shared.log(
            category: .general,
            message: "[OnlineModelManager] Deleted \(type.rawValue) model: \(config.id)"
        )
    }
    
    /// Get API Key for a model configuration
    /// - Parameters:
    ///   - config: Model configuration
    ///   - type: Model type
    /// - Returns: API Key string, or nil if not found
    func getAPIKey(for config: OnlineModelConfig, type: OnlineModelType) -> String? {
        return keychainService.load(for: config.id.uuidString, modelType: type)
    }
    
    // MARK: - Private Helpers
    
    private func loadAllConfigs() {
        // Load ASR models
        if let data = defaults.data(forKey: asrModelsKey),
           let configs = try? JSONDecoder().decode([OnlineModelConfig].self, from: data) {
            asrModels = configs
        }
        
        // Load LLM models
        if let data = defaults.data(forKey: llmModelsKey),
           let configs = try? JSONDecoder().decode([OnlineModelConfig].self, from: data) {
            llmModels = configs
        }
    }
    
    private func saveConfigs(_ configs: [OnlineModelConfig], key: String) {
        if let data = try? JSONEncoder().encode(configs) {
            defaults.set(data, forKey: key)
        }
    }
}
//
//  APIKeyVerifier.swift
//  MeetingSonar
//
//  F-9.3: API Key verification logic for online service providers
//

import Foundation

/// Verification result
enum VerificationResult {
    case success
    case failure(String)
}

/// Service for verifying API Keys
@MainActor
final class APIKeyVerifier {
    
    static let shared = APIKeyVerifier()
    
    private init() {}
    
    // MARK: - Public API
    
    /// Verify API Key by making a test request to the service provider
    /// - Parameters:
    ///   - config: Model configuration to verify
    ///   - apiKey: API Key to verify
    ///   - type: Model type (ASR/LLM)
    /// - Returns: Verification result
    func verify(config: OnlineModelConfig, apiKey: String, type: OnlineModelType) async -> VerificationResult {
        
        LoggerService.shared.log(
            category: .general,
            message: "[APIKeyVerifier] Verifying \(config.provider.displayName) \(type.rawValue) model"
        )
        
        // Construct URL
        let baseURL = config.baseURL
        let path = config.provider.verificationPath(for: type)
        
        guard let url = URL(string: baseURL + path) else {
            return .failure("无效的 Base URL")
        }
        
        // Create request
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Add authorization header (provider-specific)
        switch config.provider {
        case .zhipu:
            request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        case .deepseek:
            request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        case .qwen:
            request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        }
        
        // Create minimal test payload
        let testPayload = createTestPayload(for: config, type: type)
        request.httpBody = testPayload
        
        // Make request
        do {
            let (data, response) = try await URLSession.shared.data(for: request)
            
            guard let httpResponse = response as? HTTPURLResponse else {
                return .failure("无效的响应")
            }
            
            // Check status code
            if httpResponse.statusCode == 200 || httpResponse.statusCode == 201 {
                LoggerService.shared.log(
                    category: .general,
                    message: "[APIKeyVerifier] Verification successful"
                )
                return .success
            } else {
                // Parse error message
                let errorMessage = parseErrorMessage(from: data, provider: config.provider)
                return .failure("验证失败 (\(httpResponse.statusCode)): \(errorMessage)")
            }
            
        } catch {
            LoggerService.shared.log(
                category: .error,
                message: "[APIKeyVerifier] Verification error: \(error.localizedDescription)"
            )
            return .failure("网络错误: \(error.localizedDescription)")
        }
    }
    
    // MARK: - Private Helpers
    
    private func createTestPayload(for config: OnlineModelConfig, type: OnlineModelType) -> Data? {
        var payload: [String: Any] = [:]
        
        switch (config.provider, type) {
        case (.zhipu, .llm), (.deepseek, .llm):
            // Minimal LLM completion request
            payload = [
                "model": config.modelName,
                "messages": [
                    ["role": "user", "content": "Hi"]
                ],
                "max_tokens": 1
            ]
            
        case (.qwen, .llm):
            // Qwen LLM format
            payload = [
                "model": config.modelName,
                "input": [
                    "messages": [
                        ["role": "user", "content": "Hi"]
                    ]
                ],
                "parameters": [
                    "max_tokens": 1
                ]
            ]
            
        case (_, .asr):
            // For ASR, we'll use a minimal payload
            // Note: Real ASR verification would require an audio file
            // For now, we'll just test authentication
            payload = [
                "model": config.modelName
            ]
        }
        
        return try? JSONSerialization.data(withJSONObject: payload)
    }
    
    private func parseErrorMessage(from data: Data, provider: OnlineServiceProvider) -> String {
        guard let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            return "未知错误"
        }
        
        // Try common error message fields
        if let error = json["error"] as? [String: Any],
           let message = error["message"] as? String {
            return message
        }
        
        if let message = json["message"] as? String {
            return message
        }
        
        if let errorMsg = json["error_msg"] as? String {
            return errorMsg
        }
        
        return "未知错误"
    }
}
//
//  OnlineModelsListView.swift
//  MeetingSonar
//
//  F-9.3: Online models list view with ASR/LLM tabs
//

import SwiftUI

struct OnlineModelsListView: View {
    
    @StateObject private var manager = OnlineModelManager.shared
    
    @State private var selectedTab: OnlineModelType = .asr
    @State private var showAddSheet: Bool = false
    @State private var editingConfig: OnlineModelConfig? = nil
    @State private var showDeleteConfirm: Bool = false
    @State private var configToDelete: OnlineModelConfig? = nil
    @State private var showError: Bool = false
    @State private var errorMessage: String = ""
    
    var body: some View {
        VStack(spacing: 0) {
            // Tab selector
            Picker("", selection: $selectedTab) {
                Text("ASR 模型").tag(OnlineModelType.asr)
                Text("LLM 模型").tag(OnlineModelType.llm)
            }
            .pickerStyle(.segmented)
            .padding()
            
            Divider()
            
            // Model list
            Group {
                if currentModels.isEmpty {
                    emptyStateView
                } else {
                    modelListView
                }
            }
        }
        .sheet(isPresented: $showAddSheet) {
            AddEditModelSheet(modelType: selectedTab)
        }
        .sheet(item: $editingConfig) { config in
            AddEditModelSheet(modelType: selectedTab, existingConfig: config)
        }
        .alert("确认删除", isPresented: $showDeleteConfirm) {
            Button("取消", role: .cancel) {}
            Button("删除", role: .destructive) {
                deleteConfig()
            }
        } message: {
            Text("确定要删除此模型配置吗？API Key 也将从 Keychain 中移除。")
        }
        .alert("删除失败", isPresented: $showError) {
            Button("确定", role: .cancel) {}
        } message: {
            Text(errorMessage)
        }
    }
    
    // MARK: - Subviews
    
    private var emptyStateView: some View {
        VStack(spacing: 16) {
            Image(systemName: "externaldrive.badge.plus")
                .font(.system(size: 48))
                .foregroundColor(.secondary)
            
            Text("暂无在线 \(selectedTab.displayName)")
                .font(.title3)
                .foregroundColor(.secondary)
            
            Text("点击右上角「添加」按钮开始配置")
                .font(.caption)
                .foregroundColor(.secondary)
            
            Button("+ 添加模型") {
                showAddSheet = true
            }
            .buttonStyle(.borderedProminent)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
    
    private var modelListView: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Header
            HStack {
                Text("\(selectedTab.displayName) 列表")
                    .font(.headline)
                    .foregroundColor(.secondary)
                Spacer()
                Button(action: { showAddSheet = true }) {
                    Label("添加", systemImage: "plus.circle")
                }
                .buttonStyle(.borderless)
            }
            .padding()
            
            Divider()
            
            // List
            ScrollView {
                VStack(spacing: 12) {
                    ForEach(currentModels) { config in
                        modelRow(config)
                    }
                }
                .padding()
            }
        }
    }
    
    private func modelRow(_ config: OnlineModelConfig) -> some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                // Status icon
                Image(systemName: config.isVerified ? "checkmark.circle.fill" : "exclamationmark.triangle.fill")
                    .foregroundColor(config.isVerified ? .green : .orange)
                
                // Provider and model name
                Text("\(config.provider.displayName) - \(config.modelName)")
                    .font(.headline)
                
                Spacer()
                
                // Actions
                Button(action: { editingConfig = config }) {
                    Text("编辑")
                }
                .buttonStyle(.borderless)
                
                Button(action: {
                    configToDelete = config
                    showDeleteConfirm = true
                }) {
                    Text("删除")
                }
                .buttonStyle(.borderless)
                .foregroundColor(.red)
            }
            
            // Base URL
            Text("Base URL: \(config.baseURL)")
                .font(.caption)
                .foregroundColor(.secondary)
            
            // Status
            HStack {
                Text("状态:")
                    .font(.caption)
                    .foregroundColor(.secondary)
                Text(config.isVerified ? "已验证" : "未验证")
                    .font(.caption)
                    .foregroundColor(config.isVerified ? .green : .orange)
            }
            
            // Parameters (if any)
            if let temp = config.temperature, let maxTokens = config.maxTokens {
                HStack {
                    Text("参数:")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    if selectedTab == .llm, let topP = config.topP {
                        Text("T=\(String(format: "%.1f", temp)), MaxTokens=\(maxTokens), TopP=\(String(format: "%.2f", topP))")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    } else {
                        Text("T=\(String(format: "%.1f", temp)), MaxTokens=\(maxTokens)")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            }
        }
        .padding()
        .background(Color(nsColor: .controlBackgroundColor))
        .cornerRadius(8)
    }
    
    // MARK: - Helpers
    
    private var currentModels: [OnlineModelConfig] {
        selectedTab == .asr ? manager.asrModels : manager.llmModels
    }
    
    private func deleteConfig() {
        guard let config = configToDelete else { return }
        
        do {
            try manager.delete(config: config, type: selectedTab)
        } catch {
            errorMessage = error.localizedDescription
            showError = true
        }
        
        configToDelete = nil
    }
}
//
//  AddEditModelSheet.swift
//  MeetingSonar
//
//  F-9.3: Add/Edit online model configuration sheet
//

import SwiftUI

struct AddEditModelSheet: View {
    
    @Environment(\.dismiss) var dismiss
    @StateObject private var manager = OnlineModelManager.shared
    @StateObject private var verifier = APIKeyVerifier.shared
    
    // MARK: - Properties
    
    let modelType: OnlineModelType
    let existingConfig: OnlineModelConfig?
    
    // MARK: - State
    
    @State private var provider: OnlineServiceProvider = .zhipu
    @State private var modelName: String = ""
    @State private var baseURL: String = ""
    @State private var apiKey: String = ""
    @State private var temperature: String = ""
    @State private var maxTokens: String = ""
    @State private var topP: String = ""
    
    @State private var showAPIKey: Bool = false
    @State private var isVerifying: Bool = false
    @State private var showError: Bool = false
    @State private var errorMessage: String = ""
    
    // MARK: - Initialization
    
    init(modelType: OnlineModelType, existingConfig: OnlineModelConfig? = nil) {
        self.modelType = modelType
        self.existingConfig = existingConfig
    }
    
    // MARK: - Body
    
    var body: some View {
        VStack(spacing: 20) {
            // Header
            HStack {
                Text(existingConfig == nil ? "添加在线 \(modelType.displayName)" : "编辑在线 \(modelType.display Name)")
                    .font(.title2)
                    .fontWeight(.semibold)
                Spacer()
                Button(action: { dismiss() }) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.title2)
                        .foregroundColor(.secondary)
                }
                .buttonStyle(.plain)
            }
            
            Form {
                // Provider selection
                Picker("模型提供商:", selection: $provider) {
                    ForEach(OnlineServiceProvider.allCases, id: \.self) { p in
                        Text(p.displayName).tag(p)
                    }
                }
                .onChange(of: provider) { _ in
                    updateDefaultValues()
                }
                
                // Model name
                VStack(alignment: .leading, spacing: 4) {
                    Text("模型名称:")
                    TextField("留空使用默认: \(provider.defaultModel(for: modelType))", text: $modelName)
                        .textFieldStyle(.roundedBorder)
                }
                
                // Base URL
                VStack(alignment: .leading, spacing: 4) {
                    Text("Base URL:")
                    TextField("留空使用默认", text: $baseURL)
                        .textFieldStyle(.roundedBorder)
                    Text("默认: \(provider.defaultBaseURL)")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                // API Key
                VStack(alignment: .leading, spacing: 4) {
                    Text("API Key: *")
                    HStack {
                        if showAPIKey {
                            TextField("必填", text: $apiKey)
                                .textFieldStyle(.roundedBorder)
                        } else {
                            SecureField("必填", text: $apiKey)
                                .textFieldStyle(.roundedBorder)
                        }
                        Button(action: { showAPIKey.toggle() }) {
                            Image(systemName: showAPIKey ? "eye.slash" : "eye")
                                .foregroundColor(.secondary)
                        }
                        .buttonStyle(.plain)
                    }
                }
                
                // Advanced parameters
                DisclosureGroup("高级参数 (可选)") {
                    VStack(alignment: .leading, spacing: 12) {
                        if modelType == .llm {
                            HStack {
                                Text("Temperature:")
                                    .frame(width: 100, alignment: .leading)
                                TextField("0.0-2.0", text: $temperature)
                                    .textFieldStyle(.roundedBorder)
                                    .frame(width: 100)
                                Text("默认: 0.7")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                        }
                        
                        HStack {
                            Text("Max Tokens:")
                                .frame(width: 100, alignment: .leading)
                            TextField("响应长度限制", text: $maxTokens)
                                .textFieldStyle(.roundedBorder)
                                .frame(width: 100)
                            Text("默认: \(modelType == .llm ? "4096" : "1000")")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        
                        if modelType == .llm {
                            HStack {
                                Text("Top P:")
                                    .frame(width: 100, alignment: .leading)
                                TextField("0.0-1.0", text: $topP)
                                    .textFieldStyle(.roundedBorder)
                                    .frame(width: 100)
                                Text("默认: 0.95")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                        }
                    }
                }
            }
            
            // Actions
            HStack {
                Button("取消") {
                    dismiss()
                }
                .keyboardShortcut(.cancelAction)
                
                Spacer()
                
                if isVerifying {
                    ProgressView()
                        .scaleEffect(0.7)
                    Text("验证中...")
                        .foregroundColor(.secondary)
                } else {
                    Button("验证并保存") {
                        Task {
                            await verifyAndSave()
                        }
                    }
                    .keyboardShortcut(.defaultAction)
                    .disabled(apiKey.isEmpty)
                }
            }
        }
        .padding()
        .frame(width: 550, height: 500)
        .onAppear {
            loadExistingConfig()
        }
        .alert("保存失败", isPresented: $showError) {
            Button("确定", role: .cancel) {}
        } message: {
            Text(errorMessage)
        }
    }
    
    // MARK: - Actions
    
    private func updateDefaultValues() {
        if modelName.isEmpty {
            modelName = provider.defaultModel(for: modelType)
        }
        if baseURL.isEmpty {
            baseURL = provider.defaultBaseURL
        }
    }
    
    private func loadExistingConfig() {
        if let config = existingConfig {
            provider = config.provider
            modelName = config.modelName
            baseURL = config.baseURL
            temperature = config.temperature.map { String($0) } ?? ""
            maxTokens = config.maxTokens.map { String($0) } ?? ""
            topP = config.topP.map { String($0) } ?? ""
           
            // Load API Key
            if let key = manager.getAPIKey(for: config, type: modelType) {
                apiKey = key
            }
        } else {
            updateDefaultValues()
        }
    }
    
    private func verifyAndSave() async {
        isVerifying = true
        
        // Normalize inputs
        let finalModelName = modelName.isEmpty ? provider.defaultModel(for: modelType) : modelName
        let finalBaseURL = baseURL.isEmpty ? provider.defaultBaseURL : baseURL
        
        // Build config
        var config = OnlineModelConfig(
            id: existingConfig?.id ?? UUID(),
            provider: provider,
            modelName: finalModelName,
            baseURL: finalBaseURL,
            isVerified: false,
            temperature: Double(temperature),
            maxTokens: Int(maxTokens),
            topP: Double(topP)
        )
        
        // Verify
        let result = await verifier.verify(config: config, apiKey: apiKey, type: modelType)
        
        switch result {
        case .success:
            config.isVerified = true
            
            do {
                if existingConfig == nil {
                    try manager.add(config: config, apiKey: apiKey, type: modelType)
                } else {
                    try manager.update(config: config, apiKey: apiKey, type: modelType)
                }
                dismiss()
            } catch {
                errorMessage = error.localizedDescription
                showError = true
            }
            
        case .failure(let message):
            errorMessage = message
            showError = true
        }
        
        isVerifying = false
    }
}
