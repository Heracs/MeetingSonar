import Foundation

/// Manages application data directory paths and file naming conventions
///
/// ## Responsibilities
/// - Provides centralized access to all data directories
/// - Ensures directory structure exists on app launch
/// - Generates standardized recording file names
///
/// ## Directory Structure
/// ```
/// ~/Documents/MeetingSonar_Data/
/// ├── Recordings/          # Audio recordings (.m4a)
/// ├── Transcripts/
/// │   ├── Raw/            # Unprocessed transcripts
/// │   └── Cleansed/       # PII-removed transcripts
/// ├── SmartNotes/         # AI-generated summaries
/// ├── Models/             # Downloaded AI models
/// └── Logs/               # Application logs
/// ```
final class PathManager {
    /// Singleton instance
    static let shared = PathManager()

    private let fileManager = FileManager.default
    private let defaults = UserDefaults.standard
    private let kCustomDataRootKey = "customDataRoot"

    // MARK: - Core Directories

    /// Root data directory URL
    ///
    /// Returns `~/Documents/MeetingSonar_Data/` by default.
    /// Can be overridden via UserDefaults key `customDataRoot`.
    var rootDataURL: URL {
        // Future-proof: Check for custom path override
        if let customPath = defaults.string(forKey: kCustomDataRootKey), !customPath.isEmpty {
            do {
                // Validate custom path for security
                try PathValidator.validatePathString(customPath)
            } catch {
                LoggerService.shared.log(category: .general, level: .error, message: "[PathManager] Invalid custom path, using default: \(error.localizedDescription)")
                // Fall through to default path
            }

            // Handle both absolute paths string and file URLs if needed
            // For simplicity, we assume absolute path string for overrides
            // Expansion: users can set this via `defaults write com.meetingsonar.app customDataRoot "/path/to/dir"`
            return URL(fileURLWithPath: customPath)
        }

        // Default: ~/Documents/MeetingSonar_Data/
        // Note: We avoid "Application Support" to keep data user-visible as requested.
        guard let documentsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else {
            fatalError("PathManager: Unable to access Documents directory.")
        }
        return documentsURL.appendingPathComponent("MeetingSonar_Data")
    }

    /// Recordings directory URL
    ///
    /// Contains all audio recording files (.m4a format)
    var recordingsURL: URL {
        return rootDataURL.appendingPathComponent("Recordings")
    }

    /// Transcripts directory URL
    ///
    /// Contains both raw and cleansed transcript files
    var transcriptsURL: URL {
        return rootDataURL.appendingPathComponent("Transcripts")
    }

    /// Raw (unprocessed) transcripts directory URL
    ///
    /// Contains transcripts with potential PII (Personally Identifiable Information)
    var rawTranscriptsURL: URL {
        return transcriptsURL.appendingPathComponent("Raw")
    }

    /// Cleansed transcripts directory URL
    ///
    /// Contains transcripts with PII removed (names, numbers, etc.)
    var cleansedTranscriptsURL: URL {
        return transcriptsURL.appendingPathComponent("Cleansed")
    }

    /// Smart Notes directory URL
    ///
    /// Contains AI-generated meeting summaries and notes
    var smartNotesURL: URL {
        return rootDataURL.appendingPathComponent("SmartNotes")
    }

    /// AI models directory URL
    ///
    /// Contains downloaded AI model files (Whisper, Llama, VAD, etc.)
    var modelsURL: URL {
        return rootDataURL.appendingPathComponent("Models")
    }

    /// Logs directory path
    ///
    /// Moved from Application Support to user-visible location in v0.5.1
    /// Contains application log files for debugging
    var logsURL: URL {
        return rootDataURL.appendingPathComponent("Logs")
    }

    // MARK: - MLX/Qwen3-ASR Environment (F-5.14b)

    /// uv project configuration file path
    ///
    /// Contains project dependencies and configuration for MLX + Qwen3-ASR
    var uvProjectPyprojectPath: URL {
        return rootDataURL.appendingPathComponent("pyproject.toml")
    }

    /// uv lock file path
    ///
    /// Generated by uv to pin exact package versions
    var uvLockPath: URL {
        return rootDataURL.appendingPathComponent("uv.lock")
    }

    /// MLX virtual environment path
    ///
    /// Contains Python environment managed by uv for MLX backend
    var mlxVenvURL: URL {
        return rootDataURL.appendingPathComponent(".venv-mlx-qwen3asr")
    }

    /// Python executable within MLX venv (Apple Silicon)
    var mlxPythonExecutableURL: URL {
        #if arch(arm64)
        return mlxVenvURL.appendingPathComponent("bin/python")
        #else
        return mlxVenvURL.appendingPathComponent("Scripts/python.exe")
        #endif
    }

    // MARK: - Initialization

    private init() {}

    // MARK: - Directory Management

    /// Ensures the directory tree exists
    ///
    /// Creates all required directories if they don't exist.
    /// Should be called on app launch to guarantee data storage availability.
    func ensureDataDirectories() {
        let paths = [
            rootDataURL,
            recordingsURL,
            transcriptsURL,
            rawTranscriptsURL,
            cleansedTranscriptsURL,
            smartNotesURL,
            modelsURL,
            logsURL
            // Note: mlxVenvURL is created by UvProjectManager when needed
            // Note: uvProjectPyprojectPath is a file, not a directory
        ]

        for path in paths {
            if !fileManager.fileExists(atPath: path.path) {
                do {
                    try fileManager.createDirectory(at: path, withIntermediateDirectories: true, attributes: nil)
                    LoggerService.shared.log(category: .general, level: .info, message: "[PathManager] Created directory: \(path.path)")
                } catch {
                    LoggerService.shared.log(category: .general, level: .error, message: "[PathManager] Failed to create directory at \(path.path): \(error)")
                }
            }
        }
    }


    // MARK: - File Naming

    /// Safely constructs a URL by appending a filename to a directory URL
    ///
    /// - Parameters:
    ///   - directory: The base directory URL
    ///   - filename: The filename to append (will be validated)
    /// - Returns: A safe URL constructed with validated path components
    /// - Note: This is a security-focused wrapper that prevents path traversal attacks
    private func safeAppendingFilename(to directory: URL, filename: String) -> URL {
        do {
            return try PathValidator.safeAppendingPathComponent(to: directory, component: filename)
        } catch {
            LoggerService.shared.log(category: .general, level: .error, message: "[PathManager] Path validation failed for filename '\(filename)': \(error.localizedDescription)")
            // Fallback to unsafe for safety
            return directory.appendingPathComponent(filename)
        }
    }

    /// Generates a standardized recording file URL
    ///
    /// File format: `{YYYYMMDD}-{HHmm}_{Source}.m4a`
    ///
    /// - Parameter source: Recording source identifier (default: "Mic")
    /// - Returns: URL for the new recording file
    ///
    /// ## Examples
    /// - `"Mic"` → `20250205-1430_Mic.m4a`
    /// - `"Teams"` → `20250205-1430_Teams.m4a`
    func generateRecordingURL(source: String = "Mic") -> URL {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyyMMdd-HHmm"
        let timestamp = formatter.string(from: Date())

        // Sanitize source string just in case
        let safeSource = source.replacingOccurrences(of: " ", with: "")
                               .replacingOccurrences(of: "/", with: "-")

        let filename = "\(timestamp)_\(safeSource).m4a"
        return safeAppendingFilename(to: recordingsURL, filename: filename)
    }
}
